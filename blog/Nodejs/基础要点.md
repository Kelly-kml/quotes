<!--
 * @Description:
 * @author: kelly
 * @Date: 2024-05-14 14:42:33
 * @LastEditTime: 2024-05-15 00:13:45
-->

## Node.js 面试试题总结

### 对于 Node.js 的理解，有什么优缺点？可以怎么使用呢？

#### 概念：

Node.js 是一个开源与跨平台的 Javascript 运行环境，在浏览器外运行 V8 Javascript 引擎（Google Chrome 的内核），利用事件驱动，非阻塞和异步输入输出模型等技术提高性能。

简单来说，就是一个服务器端的、非阻塞式 I/O 的、事件驱动的 JS 运行环境。

- 非阻塞异步

`Node.js`采用了非阻塞型 I/O 机制，在做 I/O 操作的时候不会造成任何的阻塞，当完成之后，以时间的形式通知执行操作

例如在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。

- 事件驱动

事件驱动就是当进来一个新的请求时，请求将会被压入一个事件队列中，然后通过一个循环来检测队列中的事件状态变化，如果检测到有状态变化的事件，那么就执行该事件对应的处理代码，一般都是回调函数。

比如读取一个文件，文件读取完毕后，就会触发对应的状态，然后通过对应的回调函数来进行处理

下面用一张图来直观地展示事件驱动的原理：

![f88d92e6e22d14a78585ab50a2fbf3d.png](https://s2.loli.net/2024/05/14/mauUFDP8yZ7IgsY.png)

#### 优缺点：

##### 优点：

- 处理高并发场景性能更好一些

- 适合 I/O 密集型应用，简单讲就是当应用在运行极限时，CPU 占用率仍然比较低，大部分时间是在做 I/O 硬盘内存读写操作

##### 缺点：

Node.js 的缺点主要是由它本是是单线程所致的，主要体现在：

- 不适合 CPU 密集型应用

- 只支持单核 CPU，不能充分利用 CPU

- 可靠性低，一旦代码某个环节奔溃，整个系统都会奔溃

#### 应用场景：

结合他的优缺点可以从这三个方面入手考虑应用的使用场景：

1. 善于 I/O，不善于计算。因为 Node.js 是一个单线程，如果计算（同步）太多，则会阻塞这个线程

-

2. 大量并发 的 I/O，应用程序内部并不需要进行非常复杂的处理

3. 与 WebSocket 配合，开发长连接的实时交互应用程序

从上面的三个方面，具体的使用表现有：

场景 1. 用户表单收集系统、后台管理系统、考试系统、联网系统、高并发量的 web 应用程序

场景 2. 基于 web、canvas 等多人联网游戏

场景 3. 基于 web 的多人实时聊天客户端、聊天室、图文直播

场景 4. 单页面浏览器应用程序

场景 5. 操作数据库、为前端和移动端提供基于`json`的`API`

### Node 中的`fs`模块你有什么理解？

#### 概念：

fs(filesystem)，该模块提供本地文件的读写能力，基本上是 POSIX 文件操作命令的简单包装，换种方式说，所有的文件操作都是通过`fs`核心模块实现的。

```js
const fs = require('fs');
```

这个模块对所有文件系统操作提供异步（不具备 sync 后缀）和同步（具有 sync 后缀）两种操作方式供开发者选择。

#### 常见的方法：

- 文件读取

- 文件写入

- 文件追加写入

- 文件拷贝

- 创建目录

##### 文件读取

1. fs.readFileSync

`同步读取`

第一个参数：读取文件的路径或者文件描述符

第二个参数：options，默认是为 null，其中 EnCoding（编码。默认值为 null）和 flag（标识位，默认为 r），也可直接传入 encoding

结果为返回文件的内容。

```javascript
const fs = require('fs');

let buf = fs.readFileSync(path.join(__dirname, '1.txt'));
let data = fs.readFileSync(path.join(__dirname, '1.txt`, "utf-8"));

console.log(buf);
console.log(data);
```

2. fs.readFile

`异步读取`

与同步读取的前两个参数一致

最后一个参数为回调函数，函数内有两个参数 err 和 data，该方法没有返回值，回调函数在读取文件成功后执行

```js
const fs = require('fs');

fs.readFile('1.txt', 'utf8', (err, data) => {
  if (!err) {
    console.log(data); // hello
  }
});
```

##### 文件写入

1. writeFileSync

`同步写入`

三个参数：

第一个参数：文件路径或文件描述符

第二个参数：写入的数据，类型为 String 或 buffer

第三个参数：options，默认为 null，其中 EnCoding（编码。默认值为 utf-8）、 flag（标识位，默认为 w）和 mode（权限位，默认 0o666），也可直接传入 encoding

```js
const fs = require('fs');

fs.writeFileSync('2.txt', 'hello world');
let data = fs.readFileSync('2.txt', 'utf8');

console.log(data);
```

2. writeFile

`异步写入`

与同步读取的前三个参数一致

最后一个参数为回调函数，函数内有一个参数 err（错误），回调函数在文件写入数据成功后执行

```js
const fs = require('fs');

FS.writeFile('2.txt', 'hello world', (err) => {
  if (!err) {
    fs.readFile('2.txt', 'utf-8', (err, data) => {
      console.log(data);
    });
  }
});
```

##### 文件追加写入

1. appendFileSync

第一个参数：写入文件的路径或者文件描述符

第二个参数：写入的数据，类型为 String 或者 Buffer

第三个参数：options，默认为 null，其中 EnCoding（编码，默认为 utf-8）、flag（标识位，默认为 a）和 mode（权限位，默认为 0o666），也可以直接传入 eccoding

```js
const fs = require('fs');

fs.appendFileSync('3.txt', 'word');

let data = fs.readFileSync('3.txt', 'utf8');
```

2. appendFile

前三个参数与 appendFileSync 一样

最后一个参数为回调函数，函数内一个参数 err，回调函数在文件追加写入数据成功后执行

```js
const fs = require('fs');

fs.appendFile("3.txt", "word", err => {
  if(!err){
    fs.readFile('3.txt', 'utf8', (err, data))=>{
      console.log(data);
    }
  }
})
```

##### 文件拷贝

1. copyFileSync

`同步拷贝`

```js
const fs = require('fs');

fs.copyFileSync('3.txt', '4.txt');
let data = fs.readFileSync('4.txt', 'utf8');

console.log(data); // Hello world
```

2. copyFile

```js
const fs = require('fs');

fs.copyFile('3.txt', '4.txt', () => {
  fs.readFile('4.txt', 'utf8', (err, data) => {
    console.log(data); // Hello world
  });
});
```

##### 创建目录

1. mkdirSync

`同步创建`

参数为一个目录的路径，没有返回值，在创建目录的过程中，必须保证传入的路径前面的文件都存在，否则会抛出异常

```js
// 假设已经有了a文件夹和a文件夹下的b 文件夹
fs.mkdirSync('a/b/c');
```

2. mkdir

`异步创建`

第二个参数为回调函数

```js
fs.mkdir('a/b/c', (err) => {
  if (!err) console.log(' ');
});
```

### Buffer 你是怎么理解的？

#### 概念

准确来说，Buffer 是一种计算机中数据流结构。计算机中是以二进制的方式，进行数据存取的。

而 JS 在一开始，没有文件读写能力的，就要借助 Buffer 来实现一些缓冲区的内容。

Buffer 一般用于固定长度的缓冲区序列

其存储的方式如下图所示：

![16b308336f88b497dfaf9b25d38e72f.png](https://s2.loli.net/2024/05/14/TBb3PGZKeLHhnfu.png)

#### 使用方法

Buffer 在全局作用域中，无须 require 导入

创建 Buffer 的常见形式：

- Buffer.from()

```js
const b1 = Buffer.from('10');
const b2 = Buffer.from('10', 'utf8');
const b3 = Buffer.from([10]);
const b4 = Buffer.from(b3);
console.log(b1, b2, b3, b4); // <Buffer 31 30> <Buffer 31 30> <Buffer 0a> <Buffer 0a>
```

- Buffer.alloc()

```js
const bAlloc1 = Buffer.alloc(10); // 创建一个大小为10个字节的缓冲区
const bAlloc2 = Buffer.alloc(10, 1); // 创建一个长度为10 的Buffer,其中全部填充了值为1的字节

console.log(bAlloc1); // <Buffer 00 00 00 00 00 00 00 00 00 00>
console.log(bAlloc2); // <Buffer 01 01 01 01 01 01 01 01 01 01>
```

#### 应用场景

Buffer 的应用场景常与流（Stream）的概念联系在一起，主要有以下几个应用场景：

- I/O 操作

通过流的形式，将一个文件的内容读取到另一个文件中

```js
const fs = require('fs');

const inputStream = fs.createReadStream('input.txt'); // 创建可读流
const outputStream = fs.createWriteStream('output.txt'); // 创建可写流

inputStream.pipe(outputStream); // 管道读写
```

- 加密解密

在一些加密算法中会遇到使用 Buffer，例如 crypto.createCipheriv 的第二个参数 key 为 string 或 buffer 类型

- zlib.js

zlib.js 为 Node.js 的核心库之一，其利用了缓冲区（Buffer）的功能来操作二进制数据流，提供了压缩或解压的功能
