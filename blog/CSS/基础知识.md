<!--
 * @Description: CSS基础知识
 * @author: kelly
 * @Date: 2023-09-19 21:51:59
 * @LastEditTime: 2023-09-20 22:52:10
-->

## 1、CSS 选择器及优先级

（1）选择器

- id 选择器（#myId）
- 类选择器（.myClass）
- 属性选择器（a[rel="external"]）
- 伪类选择器（a:hover，li:nth-child）
- 标签选择器（div，h1，p）
- 相邻选择器（h1 + p）
- 子选择器（ul> li）
- 后代选择器（li， a）
- 通配符选择器（\*）

（2）优先级

- ！important
- 内联样式（1000）
- ID 选择器（0100）
- 类选择器/属性选择器/伪类选择器（0010）
- 元素选择器/伪元素选择器（0001）
- 关系选择器/通配符选择器（0000）

带！important 标记的样式属性优先级最高；样式表的来源相同时：！important > 行内样式 > ID 选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性

## 2、position 属性的值有被那些及其区别？

（1）**固定定位 fixed**：元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的，她也不会移动。

fixed 定位使得元素与文档流无关，因此不占据空间。fixed 定位的元素和其他元素重叠。

（2）**相对定位 relative**：如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素相对于他的起点进行移动。在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其他框。

（3）**绝对定位 absolute**: 绝对定位的元素的位置相对于最近的已定位的父元素，如果元素没有已定位的父元素，那么他的位置相对于 absolute 定位使元素的位置与文档流无关，因此不占空间。absolute 定位的元素和其他元素重叠。

（4）**粘性定位 sticky**：元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。

（5）**默认定位 static**: 默认值，没有定位，元素出现在正常的流中（忽略 top,bottom,left,right 或者 z-index 声明）。inherit:规定应该从父元素继承 position 属性的值。

## 3、盒子模型

盒子模型：当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型，将所有元素表示为一个个矩形的盒子。

盒子模型分为两种，分别是 W3C 标准盒模型和 IE（怪异）盒模型。

W3C 标准盒模型：盒子的总宽（高）度 = width + padding + border + margin
IE（怪异）盒模型：盒子的总宽（高）度 = width + margin，（其中 width 包括 width+padding+border）

在 CSS 中有一个属性 box-sizing 用来控制浏览器的渲染使用哪一种盒子模型，

box-sizing 有三个属性：

- content-box：使用 W3C 标准盒模型
- border-box: 使用 IE 盒模型
- inherit: 继承父元素的类型

## BFC（块级格式上下文）

（1）是什么？

我们在页面布局时，经常会出现以下的情况：

- 这个元素高度怎么没了？
- 这两栏布局怎么没法自适应？
- 这两个元素的间距怎么有点奇怪？
- 。。。。

其实这些都是设计 BFC 的概念。

BFC（Block Formatting Context），即块级格式化上下文，它是页面中的一块渲染区域，并且有一套属于自己的规则：

- 内部的盒子会在垂直方向上一个接一个放置
- 对于同一个 BFC 的两个相邻的盒子的 margin 会发生重叠，与方向无关
- 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此
- BFC 的区域不会与 float 的元素区域重叠
- 计算 BFC 的高度时，浮动子元素也参与计算
- BFC 就是页面上的一个隔离的独立容器，容器里面的元素不会影响到外面的元素，反之亦然。

BFC 的目的是**形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素。**

（2）触发条件：

包括但是不限于以下

- 根元素，即 HTML 元素
- 浮动元素：float 设置为 left、right
- overflow 值不为 visible，为 auto、scroll、hidden
- display 的值为 inline-block、inline-table、inline-cell、table-caption、table、flex、inline-flex、grid、inline-grid
- position 为 absolute、fixed

（3）应用场景：

- 防止 margin 重叠（坍塌）

```js
<style>
  p {
    color: #f55;
    background: #fcc;
    width: 200px;
    line-height: 100px;
    text-align: center;
    margin: 100px;
  }
</style>

<body>
  <p>first</p>
  <p>second</p>
</body>
```

两个 p 之间的距离只有 100px，就是因为发生了 margin 重叠。如果其中一个 margin 为 80px，那么两个 p 之间的距离还是 100px，以最大的为准。

**同一个 BFC 的两个相邻盒子的 margin 会发生重叠。**

解决方案：可以在 p 外面包裹一层容器，并触发这个容器生成一个 BFC，那么就不会发生重叠了。（代码如下）

```js

<style>
  .wrap {
    overflow: hidden;// 新BFC
  }
  p {
    color: #f55;
    background: #fcc;
    width: 200px;
    line-height: 100px;
    text-align: center;
    margin: 100px;
  }
</style>

<body>
  <p>Haha</p>
  <div class="wrap">
    <p>Hehe</p>
  </div>
</body>

```

- 清除内部浮动

```js
<style>
  .par {
    overflow: hidden;
    border: 5px solid #fcc;
    width: 300px;
  }

  .child {
    border: 5px solid #f66;
    width: 100px;
    height: 100px;
    float: left;
  }
</style>

<body>
  <div class="par">
    <div class="child">child1</div>
    <div class="child">child2</div>
  </div>
</body>
```

BFC 在计算高度时，浮动元素也会参与，所以我们可以触发.par 元素生成 BFC，则内部浮动元素计算高度时也会计算。

```js
  .par {
    overflow: hidden; //加上这个生成BFC
    border: 5px solid #fcc;
    width: 300px;
  }

```

- 自适应多栏布局

```js
<style>
  body {
    width: 300px;
    position: relative;
    overflow: hidden;
  }

  .aside {
    width: 100px;
    height: 150px;
    float: left;
    background: #f66;
  }

  .main {
    height: 200px;
    background: #fcc;
  }
</style>

<body>
  <div class="aside"></div>
  <div class="main"></div>
</body>
```

上面会两个 div 会重叠。

因为每个元素的左外边距与包含块的左边界相接触（从左到右），浮动元素也是如此。

而 aside 是浮动元素，main 的左边依旧会与包含块的左边相接触，而 BFC 的区域不会与浮动盒子重叠。

因此，我们可以通过触发，main 生成 BFC，以此适应两栏布局。

```css
.main {
  overflow: hidden;
}
```

这个时候，新的 BFC 不会与浮动的 aside 元素重叠，因此会根据包含块的宽度和 aside 的宽度，自动变窄。

[拓展]

上面是两栏布局，那么如果是三栏布局呢？怎么利用 BFC 实现左右固定，中间自适应呢？

```js
<style>
  .left {
    width: 100px;
    height: 150px;
    float: left;
    background: #f66;
  }

  .main {
    overflow: hidden;
    height: 200px;
    background: #fcc;
  }

  .right {
    float: right;
    height: 300px;
    width: 200px;
    background: greenyellow;
  }
</style>

<body>
  <div class="left"></div>
  <div class="right"></div>
  <div class="main"></div>
</body>
```

## 3、响应式设计是什么？基本原理了解吗？

（1）是什么？

响应式网站设计是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境（系统平台、屏幕尺寸、屏幕定向等）进行响应的响应和调整。（Content is like water）

常见特点：

- 同时适配 PC+平板+手机等
- 标签导航在接近手持终端设备时改变为经典的抽屉式导航
- 网站的布局会根据视口来调整模块的大小和位置

（2）实现方式

基本原理是：通过媒体查询检测到不同设备屏幕尺寸做了处理，为了处理移动端，页面头部必须有 meta 声明 viewport

```html
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no"
/>
```

属性对应如下：

- width=device-width：自适应手机屏幕的尺寸宽度
- maximum-scale：缩放比例的最大值
- initial-scale：缩放的初始值
- user-scalable：用户可以缩放的操作

实现响应式布局的方式如下：

- 媒体查询
- 百分比
- vw/vh
- rem

**媒体查询**

CSS 中增加了更多的媒体查询，就像 if 条件表达式一样，我们可以设置不同类型的媒体条件，并根据对应的条件，给相应符合条件的媒体类型定义不同的样式表。

使用 @media 查询，可以针对不同媒体类型定义不同的样式

```css
@media screen and (max-width: 1920px) {
  ...;
}
```

当视口在 375px-600px 之间，设置特定字体的大小 18px:

```css
@media (min-width: 375px) and (max-width: 600px) {
  body {
    font-size: 18px;
  }
}
```

通过媒体查询，我们可以给不同分辨率的设备编写不同的样式来实现响应式布局，比如我们为不同分辨率的屏幕，设置不同的背景图片。

比如给小屏幕手机设置@2X 图，为大屏幕手机设置@3X 图，通过媒体查询就能很方便实现。

**百分比**

height、width 属性的百分比依托于父标签的宽高，其他属性则不完全依赖于父元素：

- 子元素的 top/left/bottom/right 设置的百分比，则是相对于直接非 static 定位（默认定位）的父元素的宽高
- 子元素的 padding：不论垂直还是水平方向，都相对于父元素的 width，与父元素的 height 无关
- 子元素的 margin：不论垂直还是水平，都相对于直接父元素的 width
- border-radius 不一样，如果设置百分比，则是相对于自身的宽度

可以看到每个属性都使用百分比，会造成布局的复杂度变高，所以不建议使用百分比来实现响应式。

**vw/vh**

vw 表示相对于视图窗口的宽度，vh 表示相对于视图窗口高度。任意层级元素，在使用 vw 单位的情况下，1vw 等于视图宽度的 1%，100vw 等于视图宽度的 100%

**rem**

rem 是相对于根元素 html 的 font-size 属性，默认情况下浏览器字体大小为 16px,此时 1rem=16px

```css
@media screen and (max-width: 414px) {
  html {
    font-size: 18px;
  }
}
@media screen and (max-width: 375px) {
  html {
    font-size: 16px;
  }
}
@media screen and (max-width: 320px) {
  html {
    font-size: 12px;
  }
}
```

为了更精确监听设备可视窗口变化，我们可以在 CSS 之前插入 script 标签，内容如下：

```js
function init() {
  var width = document.documentElement.clientWidth;
  document.documentElement.style.fontSize = width / 10 + 'px';
}

init();
window.addEventListener('orientationchange', init);
window.addEventListener('resize', init);
```

无论设备可视窗口如何改变，始终设置 rem 为 width 的 1/10，实现了百分比布局。

（3）优点：

- 面对不用分辨率设置灵活性强
- 能够快捷解决多设备显示适应问题

## 4、元素水平垂直居中的方法有哪些？

（1）利用定位 + margin：auto

父级设置为相对定位，子级绝对定位，并且四个定位属性值都设置为 0，那么这时候如果子级没有设置宽高，则会被拉开到和父级一样的宽高；

这里子元素设置了宽高，所以宽高会按照我们的设置来显示，但是实际上子级的虚拟占位已经撑满了整个父级，这时候再给她一个 margin：auto，他就可以上下左右都居中了。

```js
<style>
  .father {
    width: 500px;
    height: 300px;
    border: 1px solid black;
    position: relative;
  }

  .son {
    width: 100px;
    height: 40px;
    background: #fcc;
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    margin: auto;
  }
</style>

<body>
  <div class="father">
    <div class="son"></div>
  </div>
</body>
```

（2）利用定位 + margin：负值

绝大多数情况下，设置父元素为相对定位，子元素移动自身 50%实现水平垂直居中

```html
<style>
  .father {
    position: relative;
    width: 500px;
    height: 500px;
    border: 1px solid black;
    position: relative;
  }

  .son {
    width: 100px;
    height: 40px;
    background: #fcc;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
  }
</style>

<body>
  <div class="father">
    <div class="son"></div>
  </div>
</body>
```

![](../CSS/定位+负值.png)

- 初始位置为方块 1 的位置
- 当设置 left、top 为 50%的时候，内部子元素为方块 2 的位置
- 设置 margin 为负数时，使得内部子元素到方块 3 的位置，即中间位置

这种方案不要求父元素的高度固定，也就是不管父级元素高度是否发生变化，子元素可以一直保持垂直水平居中；

但是这种方案需要知道子元素自身的宽高才能实现

（3）利用定位 + transform

```html
<style>
  .father {
    position: relative;
    width: 500px;
    height: 500px;
    border: 1px solid black;
  }

  .son {
    width: 100px;
    height: 40px;
    background: #fcc;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  }
</style>

<body>
  <div class="father">
    <div class="son"></div>
  </div>
</body>
```

translate(-50%, -50%)会将元素位移自己宽度和高度的-50%

这种方法其实和最上面被否定掉的 margin 负值用法一样，可以说是 margin 负值的替换方案，并不需要知道自身元素的宽高。

（4）table 布局

设置父元素为 display：table-cell，子元素设置 display：inline-block。利用 vertical 和 text-align 可以让所有的行内块级元素水平垂直居中

```html
<style>
  .father {
    display: table-cell;
    width: 500px;
    height: 500px;
    border: 1px solid black;
    vertical-align: middle;
    text-align: center;
  }

  .son {
    display: inline-block;
    width: 100px;
    height: 40px;
    background: #fcc;
  }
</style>

<body>
  <div class="father">
    <div class="son"></div>
  </div>
</body>
```

（5）flex 弹性布局

```html
<style>
  .father {
    display: flex;
    width: 500px;
    height: 500px;
    border: 1px solid black;
    justify-content: center; // 垂直居中
    align-items: center; // 水平居中
  }

  .son {
    width: 100px;
    height: 40px;
    background: #fcc;
  }
</style>

<body>
  <div class="father">
    <div class="son"></div>
  </div>
</body>
```

（6）grid 网格布局

和 flex 布局就基本一样，只是改变 display 为 grid

【小结】

如果不清楚子元素的宽高大小，要实现水平垂直居中的方法：

- 定位 + margin：auto
- 定位 + transform: translate(-50%, -50%)
- flex 布局
- grid 布局

[如果知道元素的宽高，也可以利用 定位 + margin：负值 实现]

---

根据元素标签的性质，可以分为：

- 内联元素的居中布局
- 块级元素的居中布局

（1）内联元素居中：

**水平居中**

- 行内元素可设置：text-align: center
- flex 布局设置父元素：display：flex; justify-content:center

**垂直居中**

- 单行文本父元素确认高度：height=== line-height
- 多行文本父元素确认高度：display:table-cell; vertical-align: middle

（2）块级元素居中布局

**水平居中**

- 定宽：margin：0 auto;
- 绝对定位 + left:50% + margin:负自身一半

**垂直居中**

- position:absolute, 设置 left/top/margin-left/margin-top(定高)
- display:table-cell
- transform:translate(-50%, -50%)
- flex(不定高，不定宽)
- grid(不定高，不定宽),兼容性相对较差
