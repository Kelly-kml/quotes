## 谈一谈 HTTP 协议优缺点

超文本传输协议，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

### HTTP 优点

1. **灵活可扩展**。一个语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片、视频等任意信息。
2. **请求-应答模式**。通常，就是一方发送信息，另一方要接受消息，或者作出响应等。
3. **可靠传输**。HTTP 是基于 TCP/IP，因此把这一特性继承下来。
4. **无状态**。这个分场景回答。

### HTTP 缺点

1. **无状态**。有时候，需要保存信息，比如购物系统，需要留下顾客信息等，这就是不利的；另一个方面，无状态会减少网络开销，比如类似直播行业等，这就是有利的。因此这个特点需要结合实际情况分场景回答。
2. **明文传输**。即协议里的报文（主要指的是头部）不使用二进制数据，而是文本形式。这让 HTTP 的报文暴露给了外界，给攻击者带来了便利。
3. **队头阻塞**。当 HTTP 开启长连接时，共用一个 TCP 连接，当吗，某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞的问题。

---

## HTTP/1.0 HTTP1.1 HTTP2.0 版本之间的差异

### HTTP 0.9

HTTP 0.9 是第一个版本的 HTTP 版本，已过时。

他的组成及其简单，**只允许客户端发送 GET 请求，且不支持请求头，只支持纯文本**。

HTTP 0.9 具有典型的无状态性，每个事务都独立完成，事务结束时就是释放这个连接。

一次 HTTP 0.9 的传输首先要建立一个由客户端到 Web 服务器的 TCP 连接，由客户端发起一个请求，然后由 Web 服务器返回页面内容，然后连接会关闭。如果请求的页面不存在，也不会返回任何错误码。

### HTTP 1.0

1. 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。
2. 除了 GET 命令，还引进了 POST 和 HEAD。
3. http 请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
4. 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。
5. 不支持断点续传，也就是说，每次都会传送全部的页面和数据。
6. 通常每台计算机只能绑定一个 IP， 所以请求消息中的 URL 并没有传递主机名（hostname）。

### HTTP 1.1

http1.1 是目前最为主流的 http 协议版本，从 1999 年发布至今，仍是主流的 http 协议版本。

HTTP 1.1 引入了许多关键性能优化：**keepalive 连接，chunked 编码传输，字节范围请求，请求流水线**等。

1. 引入了持久连接（ persistent connection），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置。
2. 引入了管道机制（ pipelining），即在同一个 TCP 连接里，客户端可以同时发送多个请求，进一步改进了 HTTP 协议的效率。
3. HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。
4. 支持断点续传，通过使用请求头中的 Range 来实现。
5. 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。
6. 新增方法：PUT、 PATCH、 OPTIONS、 DELETE。

### http 1.x 版本问题

- 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。
- HTTP/1.1 版本默认允许复用 TCP 连接，但是在同一个 TCP 连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。
- http/1.x 版本支持 Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive 会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。

### HTTP 2.0

1. **二进制分帧**。 这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。 2.**头部压缩**。 HTTP 1.1 版本会出现 User-Agent、Cookie、Accept、Server、Range 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。
2. **多路复用**。 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。
3. **服务器推送**。 允许服务器未经请求，主动向客户端发送资源，即服务器推送。
4. **请求优先级**。 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。

---

## 谈一谈你对 HTTP/2 理解

### 头部压缩

HTTP 2.0 使用“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈弗曼编码来压缩整数和字符串，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的索引序列，可以达到非常高的压缩率。

具体来说：

- 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；

- 首部表在 HTTP/2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;

- 每个新的首部键-值对要么被追加到当前表的末尾，要么替换表中之前的值。

例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。

https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ba24e56c7c84bfda6b382cb08090961~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp

### 多路复用

HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8 个的 TCP 链接请求限制。

HTTP 2.0 中：

- 同域名下所有通信都在单个连接上完成
- 单个连接可以承载任意数量的双向数据流
- 数据流以消息的形式发送，而消息又由一个或者多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是 Stream ID,流标识符，有了它，接收方就能从乱序的二进制中选择 ID 相同的帧，按照顺序组装成请求/响应报文。

#### 为什么 HTTP1.1 不能实现多路复用（腾讯）

> 参考答案：  
> HTTP/1.1 不是二进制传输，而是通过文本进行传输。由于没有流的概念，在使用并行传输（多路复用）传递数据时，接收端在接收到响应后，并不能区分多个响应分别对应的请求，所以无法将多个响应的结果重新进行组装，也就实现不了多路复用。

### 服务器推送

浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。

相比较 http/1.1 的优势 👇

- 推送资源可以由不同页面共享
- 服务器可以按照优先级推送资源
- 客户端可以缓存推送的资源
- 客户端可以拒收推送过来的资源

### 二进制分帧

http 1.x 是明文传输，不方便计算机解析，对于回车换行符来说到底是内容还是分隔符，都需要内部状态机去识别，这样子效率低，HTTP/2 采用二进制格式，全部传输 01 串，便于机器解码。

这样子一个报文格式就被拆分为一个个二进制帧，用 Headers 帧存放头部字段，Data 帧存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，**解决了 HTTP 队头阻塞问题**。

在客户端与服务器之间，双方都可以互相发送二进制帧，这样子**双向传输的序列，称为流**，所以 HTTP/2 中以流来表示一个 TCP 连接上进行多个数据帧的通信，这就是多路复用概念。

那乱序的二进制帧，是如何组装成对于的报文呢？

- 所谓的乱序，值的是不同 ID 的 Stream 是乱序的，对于同一个 Stream ID 的帧是按顺序传输的。
- 接收方收到二进制帧后，将相同的 Stream ID 组装成完整的请求报文和响应报文。
- 二进制帧中有一些字段，控制着优先级和流量控制等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。

---

## 介绍一下 HTTP 常见状态码

RFC 规定 HTTP 的状态码为三位数，第一个数字定义了响应的类别，被分为五类:

- 1xx: 代表请求已被接受，需要继续处理。
- 2xx: 表示成功状态。
- 3xx: 重定向状态。
- 4xx: 客户端错误。
- 5xx: 服务器端错误。

### 1xx 信息类

接受的请求正在处理，信息类状态码。

### 2xx 成功

- 200 OK 表示从客户端发来的请求在服务器端被正确请求。
- 204 No content，表示请求成功，但没有资源可返回。
- 206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求响应报文中包含由 Content-Range 指定范围的实体内容。

### 3xx 重定向

- 301 moved permanently，**永久性重定向**，表示资源已被分配了新的 URL，这时应该按 Location 首部字段提示的 URI 重新保存，比如域名变更。
- 302 found，**临时性重定向**，表示资源临时被分配了新的 URL，比如首页临时跳转活动页。
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源。
- 304 not modified，当协商缓存命中时会返回这个状态码。
- 307 temporary redirect，临时重定向，和 302 含义相同,不会改变 method

> 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送  
> 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做

### 4XX 客户端错误

- 400 bad request，请求报文存在语法错误。
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息。
- 403 forbidden，表示对请求资源的访问被服务器拒绝。
- 404 not found，表示在服务器上没有找到请求的资源。
- 405 Method Not Allowed，服务器禁止使用该方法，客户端可以通过 options 方法来查看服务器允许的访问方法，如下 👇

```js
Access-Control-Allow-Methods →GET,HEAD,PUT,PATCH,POST,DELETE
```

### 5XX 服务器错误

- 500 internal sever error，表示服务器端在执行请求时发生了错误。
- 502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。

---

## DNS 如何工作的？

DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。是应层协议，通常该协议运行到 UDP 协议之上，使用的是 53 端口号。

我们通过一张图来看看他的查询过程吧 👇

https://user-images.githubusercontent.com/34484322/89356512-95168e80-d6f0-11ea-93aa-c4f59fd36942.png

这张图清晰展示了 DNS 在本地 DNS 服务器是如何查询的，**一般向本地 DNS 服务器发送请求时递归查询的**

**本地 DNS 服务器向其他域名服务器请求的过程是迭代查询**的过程 👇

https://user-images.githubusercontent.com/34484322/89356522-99db4280-d6f0-11ea-9bf9-851b25bd16c3.png

### 递归查询和迭代查询

- 递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出一次查询请求。

- 迭代查询指的是查询请求后，域名服务器返回首次查询的结果。下一级查询由用户自己请求。使用迭代查询，用户需要发出多次的查询请求。

所以结论就是：**本地服务器查询时递归查询，本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程**。

### DNS 缓存

缓存其实就是在一个请求中，当 DNS 服务器收到一个 DNS 回答后，它能够将回答中的信息缓存在本地存储器中。

返回的资源记录中的 TTL 代表了该条记录的缓存的时间。

### DNS 实现负载平衡

它是如何实现负载均衡的呢？

首先我们得清楚 DNS 是可以用于在冗杂的服务器上实现负载平衡的。

**原因：**这是因为一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。

举个例子来说：

- 当用户发起网站域名的 DNS 请求时，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合。
- 在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。
- 以此将用户的请求均衡的分配到各个不同的服务器上，这样子来实现负载均衡。

### 总结

1. DNS 域名系统，是应用层协议，使用端口 43
2. 查询过程，本地查询时递归查询，依次通过浏览器缓存 -- 本地 hosts 文件 -- 本地 DNS 解析器 -- 本地 DNS 服务器 -- 其他域名服务器请求。
   [本地 DNS 服务器到其他域名服务器是迭代查询]

3. 递归查询一般而言，发送一次请求就够了，迭代过程需要用户发送多次请求。

## DNS 为什么使用 UDP 协议作为传输层协议？

**DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。**

- 为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。
- 大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。

---

## 介绍一下 Connection：keep-alive

### 什么是 keep-alive

HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-alive 模式时，每个请求-应答客户和服务器都要新建一个连接，完成之后又立即断开连接（HTTP 协议为无连接的协议）；

当使用 Keep-alive 模式（又称为持久连接，连接重用）时，Keep-alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后续请求时，Keep-alive 功能避免了建立或者重新建立连接。

### 为什么要使用 keep-alive?

keep-alive 技术的创建目的，能在多次 HTTP 之前重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等），参考如下示意图（来源：维基百科）：

https://user-images.githubusercontent.com/34484322/89356849-64832480-d6f1-11ea-8f53-5372f8c30f39.png

### 客户端如何开启？

在 HTTP/1.0 协议中，默认是关闭的，需要在 http 头加入"Connection: Keep-Alive”，才能启用 Keep-Alive；

```java
Connection: keep-alive
```

http 1.1 中默认启用 Keep-Alive，如果加入"Connection: close “，才关闭。

```java
Connection: close
```

目前大部分浏览器都是用 http1.1 协议，也就是说默认都会发起 Keep-Alive 的连接请求了，所以是否能完成一个完整的 Keep- Alive 连接就看服务器设置情况。

---

## 介绍 HTTP 缓存策略

浏览器缓存是性能优化的一个重要手段，对于理解缓存机制而言也是很重要的，我们来梳理一下吧 👇

### 强缓存

强缓存两个相关字段，「Expires」，「Cache-Control」。
「强缓存分为两种情况，一种是发送 HTTP 请求，一种不需要发送。」

首先检查强缓存，这个阶段**不需要发送 HTTP 请求**，通过查找不同的字段来进行，不同的 HTTP 版本所以不同。

HTTP1.0 版本，使用的是 Expires，HTTP1.1 使用的是 Cache-Control

1. Expires

Expires 即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:

```js
Expires:Mon, 11 May 2023 11:10:23 GMT
```

表示该资源在 2023 年 5 月 11 日 11:10:23 过期，过期时就会重新向服务器发起请求。

这个方式有一个问题：「服务器的时间和浏览器的时间可能并不一致」，所以 HTTP1.1 提出新的字段代替它。

2. Cache-Control

HTTP1.1 版本中，使用的就是该字段，这个字段采用的时间是过期时长，对应的是 max-age。

```js
Cache-Control:max-age=6000
```

上面代表该资源返回后 6000 秒，可以直接使用缓存。

当然了，它还有其他很多关键的指令，梳理了几个重要的 👇

**注意点：**

- 当 Expires 和 Cache-Control 同时存在时，优先考虑 Cache-Control。
- 当然了，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存 👇

### 协商缓存

强缓存失效后，浏览器在请求头中携带响应的缓存 Tag 来向服务器发送请求，服务器根据对应的 tag，来决定是否使用缓存。

缓存分为两种，「Last-Modified」 和 「ETag」。两者各有优势，并不存在谁对谁有绝对的优势，与上面所讲的强缓存两个 Tag 所不同。

1. Last-modified

这个字段表示的是「最后修改时间」。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

浏览器接收到后，「如果再次请求」，会在请求头中携带 If-Modified-Since 字段，这个字段的值也就是服务器传来的最后修改时间。

服务器拿到请求头中的 If-Modified-Since 的字段后，其实会和这个服务器中该资源的最后修改时间对比:

- 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样。
- 否则返回 304，告诉浏览器直接使用缓存。

2. ETag

ETag 是服务器根据当前文件的内容，对文件生成唯一的标识，比如：MD5 算法，只要里面的内容有改动，这个值就会改变，服务器通过把响应头这个字段给浏览器。

浏览器接收到 ETag 值，会在下次请求的时候，将这个值作为「If-None-Match」这个字段的内容，发给服务器。

服务器接收到「If-None-Match」后，会跟服务器上该资源的「ETag」进行比对 👇

- 如果两者一样的话，直接返回 304，告诉浏览器直接使用缓存
- 如果不一样的话，说明内容更新了，返回新的资源，跟常规的 HTTP 请求响应的流程一样

#### Last-modified 与 ETag 区别：

- 性能上，Last-Modified 优于 ETag，Last-Modified 记录的是时间点，而 ETag 需要根据文件的 MD5 算法生成对应的 hash 值。
- 精度上，ETag 优于 Last-Modified。ETag 按照内容给资源带上标识，能准确感知资源变化，Last-Modified 在某些场景并不能准确感知变化，比如 👇
  - 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
  - Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。

总之，「如果两种方式都支持的话，服务器会优先考虑 ETag」。

## 缓存位置

接下来我们考虑使用缓存的话，那么缓存的位置在哪里？

浏览器缓存的位置，可以分为四种，优先级从高到低排序分别为：

- Service Worker
- Memory Cache
- Disk Cache
- Push Cache

### Service Worker

这个应用场景比如 PWA，它借鉴了 Web Worker 思路，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是 Service Worker Cache。

### Memory Cache

指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。

### Disk Cache

存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。

**Disk Cache VS Memory Cache**👇

1. 内容使用率高的话，文件优先进入磁盘

2. 比较大的 JS，CSS 文件会直接放入磁盘，反之放入内存。

### Push Cache

推送缓存，这算是浏览器中最后一道防线吧，它是 HTTP/2 的内容。

## 总结

- 首先检查 Cache-Control，看强缓存是否可用
- 如果可以直接使用
- 否则进入协商缓存，发送 HTTP 请求，服务器通过请求头中的 If-Modified-Since 或者 If-None-Match 字段检查资源是否更新
- 资源更新的话，发起新的请求，返回对应的资源和 200 状态码
- 否则，返回 304，告诉浏览器直接从缓存中取资源

---

## 说一说 HTTP 的请求方法？

- HTTP1.0 定义了三种请求方法：GET，POST 和 HEAD
- HTTP1.1 新增了五种请求方法：OPTIONS，PUT，DELETE，TRACH 和 CONNECT

http/1.1 规定了以下请求方法(注意，都是大写):

1. GET：请求获取 Request-URI 所标识的资源。
2. POST：在 Request-URI 所标识的资源后附加新的数据。
3. HEAD：请求获取由 Request-URI 所标识的资源的响应消息报头。
4. PUT：请求服务器存储一个资源，并用 Request-URI 作为其标识（修改数据）。
5. DELETE: 请求服务器删除所标识的资源。
6. TRACH：请求服务器回送收到的请求信息，主要用于测试或者诊断。
7. CONNECT： 建立连接隧道，用于代理服务器。
8. OPTIONS：列出可对资源实行的请求方法，用来跨域请求。


## 谈一谈GET 和 POST 的区别

本质上，只是语义上的区别，GET用来获取资源，POST用于提交资源。

具体差别👇

- 从缓存角度看，GET 请求后浏览器会主动缓存，POST 默认情况下不能。
- 从参数角度来看，GET请求一般放在URL中，因此不安全，POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的。
- 从编码角度看，GET请求只能经行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。
- GET请求幂等，POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致。
- GET请求会一次性发送请求报文，POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。

从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。

## options 方法有什么用？

- OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。

- 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。

- JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。